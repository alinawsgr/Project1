
//////////////////////////////// VORBEREITUNG /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// festzulegende und fixe Variablen 
// Größe Platzhalter
const nodeWith = 350;
const nodeHeight = 250;
// fixe Positionen
var xEntladerPosition = 1400;
var yEntladerPosition = 1500;

// Liest das csv-file ein und wandelt es in eine matrix um
const fs = require('fs');
function readCSV(filePath) {
    const csvData = fs.readFileSync(filePath, 'utf-8');
    const rows = csvData.trim().split('\n');
    const matrix = [];
    for (let i = 0; i < rows.length; i++) {
      const columns = rows[i].split(';');
      const updatedColumns = [];
      for (let j = 0; j < columns.length; j++) {
        const value = columns[j].trim() === '' ? '0' : columns[j].trim();
        updatedColumns.push(value);
      }
      matrix.push(updatedColumns);
    }
    return matrix;
  }
  
// Verarbeitet Matrix zu Key-Value Objekt mit x und y Positionen
// Zugriff auf Inhalte der Matrix -> Zeilen: matrix[i], Spalten: matrix.map(row => row[i]).slice(x);
matrix =readCSV('C:\\Alina\\Arbeit\\Greaph\\Excel-alscsv.csv');
//
const maschinen = matrix.map(row => row[4]).slice(2);
const xfixPositions = matrix.map(row => row[1]).slice(2);
const yfixPositions = matrix.map(row => row[2]).slice(2);

const fixemaschinen = matrix.slice(2).map(row => row[3]);
const fixmachinesstring = [];
for (let i = 0; i < fixemaschinen.length; i++) {
  if (fixemaschinen[i] != 0) {
    fixmachinesstring.push(maschinen[i]);
  }
}

console.log(fixmachinesstring);
const keyvaluepositions = [];
for (let i = 0; i < maschinen.length; i++) {
  const name = maschinen[i];
  if (name === 'Entlader') {
    keyvaluepositions[name] = { x: xEntladerPosition, y: yEntladerPosition, Quelle:"", Senke:"" };
  } else {
    keyvaluepositions[name] = { x: 0, y: 0, Quelle1:"", Senke1:"" };
  }
}
//console.log(keyvaluepositions);






/////////////////////////////////////////////////// FUNKTIONEN /////////////////////////////////////////////////////////////////////////
// Funktion, die positionnen und Abhängigkeiten von fixen Maschinen berechnet

function calculatedependencies(matrix, keyvaluepositions) {

    for (let i = 0; i < yfixPositions.length; i++) {
      if (yfixPositions[i] === 'Entlader') {
          keyvaluepositions[maschinen[i]].y = keyvaluepositions['Entlader'].y;
      }else if (yfixPositions[i] === 'Ettikettiermaschine'){
        keyvaluepositions[maschinen[i]].y = keyvaluepositions['Ettiketiermaschine'].y;
      }
    }
    for (let i = 0; i < xfixPositions.length; i++) {
        if (xfixPositions[i] === 'Entlader') {
          keyvaluepositions[maschinen[i]].x = keyvaluepositions['Entlader'].x;
        }else if (xfixPositions[i] === 'Waschmaschine'){
            keyvaluepositions[maschinen[i]].x = keyvaluepositions['Waschmaschine'].x;
        }else if (xfixPositions[i] === 'Auspacker'){
            keyvaluepositions[maschinen[i]].x = keyvaluepositions['Auspacker'].x;
        }
      }
      return keyvaluepositions;
  }

calculatedependencies(matrix,keyvaluepositions);
//console.log(calculatedependencies(matrix,keyvaluepositions));



/// Funktion, die Senke in das Key-Value Objekt einträgt
const newMatrix = matrix.map(row => row.slice(8));
    newMatrix.splice(0,2);
function findAndStoreSenken(newMatrix, maschinen, keyvaluepositions) {
    for (let i = 0; i < newMatrix[0].length; i++) {
        const senken1Liste = [];
        const senken3Liste = [];
        const senken2Liste = [];
        const senken4Liste = [];
        const senken101Liste = [];
            for (let j = 0; j < newMatrix[i].length; j++) {
              if (newMatrix[i][j] == 1) {
                senken1Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 3) {
                senken3Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 2) {
                senken2Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 4) {
                senken4Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 101) {
                senken101Liste.push(maschinen[j]);
              }
            }

          
            var maschinex = maschinen[i];
            keyvaluepositions[maschinex].Senke1 = senken1Liste;
            keyvaluepositions[maschinex].Senke2 = senken2Liste;
            keyvaluepositions[maschinex].Senke3 = senken3Liste;
            keyvaluepositions[maschinex].Senke4 = senken4Liste;
            keyvaluepositions[maschinex].Senke101 = senken101Liste;
          }
        
    for (let a=0; a<newMatrix[0].length; a++){
      const quellen1Liste = [];
      const quellen2Liste = [];
      const quellen3Liste = [];
      const quellen4Liste = [];
      const quellen101Liste = [];
      for (let b = 0; b< newMatrix.length; b++){
        if (newMatrix[b][a] == 1){
          quellen1Liste.push(maschinen[b])
        }
        else if (newMatrix[b][a] == 3){
          quellen3Liste.push(maschinen[b]);
        }
        else if (newMatrix[b][a] == 2){
            quellen2Liste.push(maschinen[b]);
        }
        else if (newMatrix[b][a] == 4){
            quellen4Liste.push(maschinen[b]);
        }
        else if (newMatrix[b][a] == 101){
            quellen101Liste.push(maschinen[b]);
        }

      }
      var maschinex = maschinen[a];
      keyvaluepositions[maschinex].Quelle1 = quellen1Liste;
      keyvaluepositions[maschinex].Quelle2 = quellen2Liste;
      keyvaluepositions[maschinex].Quelle3 = quellen3Liste;
      keyvaluepositions[maschinex].Quelle4 = quellen4Liste;
      keyvaluepositions[maschinex].Quelle101 = quellen101Liste;
    }
    return keyvaluepositions;
    }     
findAndStoreSenken(newMatrix,maschinen,keyvaluepositions);
//console.log(keyvaluepositions);

// Kalkuliert die Pfade
function findPaths(machineName, keyvaluepositions, senkeProperty) {
  const paths = [];
  const machine = keyvaluepositions[machineName];

  if (!machine) {
    return paths;
  }

  const path = [machineName];

  if (machine[senkeProperty].length > 0) {
    const nextMachineName = machine[senkeProperty][0];
    const nextPaths = findPaths(nextMachineName, keyvaluepositions, senkeProperty);

    for (const nextPath of nextPaths) {
      paths.push([...path, ...nextPath]);
    }
  } else {
    paths.push(path);
  }

  return paths;
}

// Bestimme für jedes Gewicht die Pfade 
// rote Pfeile
const pathsFromEntpackerSenke1 = findPaths("Entlader", keyvaluepositions, "Senke1");
//console.log(pathsFromEntpackerSenke1);


// gelbe Pfeile
const pathsFromEntpackerSenke2 = findPaths("Entlader", keyvaluepositions,"Senke2" );
const pathsFromAuspackerSenke2 = findPaths("Auspacker", keyvaluepositions, "Senke2");
// andere -> wo ist hier der Start?
const pathsSenke3 = findPaths("", keyvaluepositions, "Senke3");
const pathsSenke4 = findPaths("", keyvaluepositions, "Senke4");
const pathsSenke101 = findPaths("", keyvaluepositions, "Senke101");

// Funktion, die die Koordinaten basierend auf den Pfaden berechnet
function setYValuesFromEntlader(path, keyvaluepositions) {
    const entladerMachine = keyvaluepositions.Entlader;
    const entladerY = entladerMachine.y;
  
    for (const machineName of path[0]) {
      if (keyvaluepositions.hasOwnProperty(machineName)) {
        keyvaluepositions[machineName].y = entladerY;
      }
    }
  
    return keyvaluepositions;
  }
  
const updatedKeyvaluepositions = setYValuesFromEntlader(pathsFromEntpackerSenke1, keyvaluepositions);
//console.log(updatedKeyvaluepositions);
//console.log(pathsFromEntpackerSenke1);
  






// Funktion, die die Node Positions berechnet
function calculateNodePositions(startX, startY, endX, endY, nodeCount, nodeWith, nodeHeight) {
  var gap = (endY - startY) / (nodeCount + 1); // Berechnung des vertikalen Abstands
  var nodePositions = [];
  for (var i = 1; i <= nodeCount; i++) {
    var x = startX; // x-Koordinate ist konstant, da senkrecht unterhalb des Startpunkts
    var y = startY + (gap * i); // Berechnung der y-Koordinate
    nodePositions.push({ x: x, y: y }); // Hinzufügen der Knotenposition zur Liste
  }
  return nodePositions;
}
//console.log(calculateNodePositions(xEntladerPosition,yEntladerPosition,1400,3000,8));














// Funktion, die die nächsten Maschinen ausgehend von Start-Maschine berechnet
function iterateMatrix(matrix, inputString) {
    const columnNames = []; // Liste für Spaltennamen, in denen eine 1 steht
    // Finde die Zeile, die den Input-String enthält
    const row = matrix.find(row => row.includes(inputString));
  
    if (!row) {
      console.log("Der Input-String wurde nicht gefunden.");
      return columnNames;
    }
    const columnIndex = row.indexOf(inputString);
    const startRow = matrix.indexOf(row);
    for (let currentRow = startRow; currentRow < matrix.length; currentRow++) {
      // Überprüfe, ob die Spalte in der aktuellen Zeile eine 1 enthält
      if (matrix[currentRow][columnIndex] === '1') { // Beachte: Vergleich mit '1' als String
        // Finde den Spaltennamen für diese Spalte
        const columnName = matrix.map(row => row[4]).slice(2);
        columnNames.push(columnName);
        // Springe zur nächsten Spalte mit 1 in derselben Zeile
        let nextColumnIndex = columnIndex + 1;
        while (nextColumnIndex < matrix[currentRow].length && matrix[currentRow][nextColumnIndex] !== '1') {
          nextColumnIndex++;
        }
        // Wenn keine weitere Spalte mit 1 in derselben Zeile gefunden wurde, springe zur nächsten Zeile
        if (nextColumnIndex === matrix[currentRow].length) {
          nextColumnIndex = row.indexOf('1', nextColumnIndex); // Finde den nächsten Spaltenindex mit 1 in der Ausgangszeile
          if (nextColumnIndex === -1) {
            break; // Keine weiteren Spalten mit 1 gefunden, beende die Schleife
          }
          currentRow = startRow - 1; // Setze die aktuelle Zeile auf die Ausgangszeile minus 1, da die Schleife die Zeile erhöht
        }
        columnIndex = nextColumnIndex; // Aktualisiere den Spaltenindex
      }
    }
    return columnNames;
  }
  
  
  //console.log(iterateMatrix(matrix,"Entlader"));
 
