
//////////////////////////////// VORBEREITUNG /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// festzulegende und fixe Variablen 
// Größe Platzhalter
const nodeWith = 350;
const nodeHeight = 250;
// fixe Positionen
var xEntladerPosition = 1400;
var yEntladerPosition = 1500;

// Liest das csv-file ein und wandelt es in eine matrix um
const fs = require('fs');
function readCSV(filePath) {
    const csvData = fs.readFileSync(filePath, 'utf-8');
    const rows = csvData.trim().split('\n');
    const matrix = [];
    for (let i = 0; i < rows.length; i++) {
      const columns = rows[i].split(';');
      const updatedColumns = [];
      for (let j = 0; j < columns.length; j++) {
        const value = columns[j].trim() === '' ? '0' : columns[j].trim();
        updatedColumns.push(value);
      }
      matrix.push(updatedColumns);
    }
    return matrix;
  }
  
// Verarbeitet Matrix zu Key-Value Objekt mit x und y Positionen
// Zugriff auf Inhalte der Matrix -> Zeilen: matrix[i], Spalten: matrix.map(row => row[i]).slice(x);
matrix =readCSV('C:\\Alina\\Arbeit\\Greaph\\Excel-alscsv.csv');
// enthält alle Maschinen-Namen
const maschinen = matrix.map(row => row[4]).slice(2);
// enthalten fixe Positionen und Abhängigkeiten
const xfixPositions = matrix.map(row => row[1]).slice(2);
const yfixPositions = matrix.map(row => row[2]).slice(2);
// enthalten fixe Maschinen
const fixemaschinen = matrix.slice(2).map(row => row[3]);
const fixmachinesstring = [];
for (let i = 0; i < fixemaschinen.length; i++) {
  if (fixemaschinen[i] != 0) {
    fixmachinesstring.push(maschinen[i]);
  }
}
// Key-Value Objekt, das alle Koordinaten der einzelnen Maschinen beinhaltet
const keyvaluepositions = [];
for (let i = 0; i < maschinen.length; i++) {
  const name = maschinen[i];
  if (name === 'Entlader') {
    keyvaluepositions[name] = { x: xEntladerPosition, y: yEntladerPosition, Quelle:"", Senke:"" };
  } else {
    keyvaluepositions[name] = { x: 0, y: 0, Quelle1:"", Senke1:"" };
  }
}



/////////////////////////////////////////////////// FUNKTIONEN /////////////////////////////////////////////////////////////////////////

// Funktion, die positionnen und Abhängigkeiten von fixen Maschinen berechnet
function calculatedependencies(matrix, keyvaluepositions) {
    for (let i = 0; i < yfixPositions.length; i++) {
      if (yfixPositions[i] === 'Entlader') {
          keyvaluepositions[maschinen[i]].y = keyvaluepositions['Entlader'].y;
      }else if (yfixPositions[i] === 'Ettikettiermaschine'){
        keyvaluepositions[maschinen[i]].y = keyvaluepositions['Ettiketiermaschine'].y;
      }
    }
    for (let i = 0; i < xfixPositions.length; i++) {
        if (xfixPositions[i] === 'Entlader') {
          keyvaluepositions[maschinen[i]].x = keyvaluepositions['Entlader'].x;
        }else if (xfixPositions[i] === 'Waschmaschine'){
            keyvaluepositions[maschinen[i]].x = keyvaluepositions['Waschmaschine'].x;
        }else if (xfixPositions[i] === 'Auspacker'){
            keyvaluepositions[maschinen[i]].x = keyvaluepositions['Auspacker'].x;
        }
      }
      return keyvaluepositions;
  }

calculatedependencies(matrix,keyvaluepositions);


/// Funktion, die Senke in das Key-Value Objekt einträgt
const newMatrix = matrix.map(row => row.slice(8));
newMatrix.splice(0,2);
function findAndStoreSenkenQuellen(newMatrix,maschinen,keyvaluepositions){
    for (let i = 0; i < newMatrix[0].length; i++) {
        const senken1Liste = [];
        const senken3Liste = [];
        const senken2Liste = [];
        const senken4Liste = [];
        const senken101Liste = [];
            for (let j = 0; j < newMatrix[i].length; j++) {
              if (newMatrix[i][j] == 1) {
                senken1Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 3) {
                senken3Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 2) {
                senken2Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 4) {
                senken4Liste.push(maschinen[j]);
              }
              if (newMatrix[i][j] == 101) {
                senken101Liste.push(maschinen[j]);
              }
            }
            var maschinex = maschinen[i];
            keyvaluepositions[maschinex].Senke1 = senken1Liste;
            keyvaluepositions[maschinex].Senke2 = senken2Liste;
            keyvaluepositions[maschinex].Senke3 = senken3Liste;
            keyvaluepositions[maschinex].Senke4 = senken4Liste;
            keyvaluepositions[maschinex].Senke101 = senken101Liste;
          }   
    for (let a=0; a<newMatrix[0].length; a++){
      const quellen1Liste = [];
      const quellen2Liste = [];
      const quellen3Liste = [];
      const quellen4Liste = [];
      const quellen101Liste = [];
      for (let b = 0; b< newMatrix.length; b++){
        if (newMatrix[b][a] == 1){
          quellen1Liste.push(maschinen[b])
        }
        else if (newMatrix[b][a] == 3){
          quellen3Liste.push(maschinen[b]);
        }
        else if (newMatrix[b][a] == 2){
            quellen2Liste.push(maschinen[b]);
        }
        else if (newMatrix[b][a] == 4){
            quellen4Liste.push(maschinen[b]);
        }
        else if (newMatrix[b][a] == 101){
            quellen101Liste.push(maschinen[b]);
        }
      }
      var maschinex = maschinen[a];
      keyvaluepositions[maschinex].Quelle1 = quellen1Liste;
      keyvaluepositions[maschinex].Quelle2 = quellen2Liste;
      keyvaluepositions[maschinex].Quelle3 = quellen3Liste;
      keyvaluepositions[maschinex].Quelle4 = quellen4Liste;
      keyvaluepositions[maschinex].Quelle101 = quellen101Liste;
    }
    return keyvaluepositions;
    }     
findAndStoreSenkenQuellen(newMatrix,maschinen,keyvaluepositions);



// Kalkuliert die Pfade abhängig von der Gewichtung
function findPaths(machineName, keyvaluepositions, senkeProperty) {
  const paths = [];
  const machine = keyvaluepositions[machineName];
  if (!machine) {
    return paths;
  }
  const path = [machineName];
  if (machine[senkeProperty].length > 0) {
    const nextMachineName = machine[senkeProperty][0];
    const nextPaths = findPaths(nextMachineName, keyvaluepositions, senkeProperty);

    for (const nextPath of nextPaths) {
      paths.push([...path, ...nextPath]);
    }
  } else {
    paths.push(path);
  }
  return paths;
}
// Bestimme für jedes Gewicht die Pfade 
// rote Pfeile
const path1 = findPaths("Entlader", keyvaluepositions, "Senke1");
const indexAfterWaschmaschine = path1.indexOf("Waschmaschine") + 1;
const path1_hor_r = path1.slice(0, indexAfterWaschmaschine);
//const path1_senkr_u
//const path1_hor_l 

// gelbe Pfeile
const path2_Entlader = findPaths("Entlader", keyvaluepositions,"Senke2" );
const path2_Auspacker = findPaths("Auspacker", keyvaluepositions, "Senke2");
// andere -> wo ist hier der Start?
const path3 = findPaths("", keyvaluepositions, "Senke3");
const path4 = findPaths("", keyvaluepositions, "Senke4");
const path101 = findPaths("", keyvaluepositions, "Senke101");


// Funktion, die die Koordinaten basierend auf den Pfaden berechnet (gelb)
function setYValuesFromEntlader(path, keyvaluepositions) {
    
    const entladerY = keyvaluepositions.Entlader.y;
    const waschmaschineY = keyvaluepositions.Waschmaschine.y;
  
    for (const machineName of path[0]) {
      if (machineName === "Waschmaschine") {
        continue;
      }
      if (keyvaluepositions.hasOwnProperty(machineName)) {
        keyvaluepositions[machineName].y = entladerY;
      }
      keyvaluepositions.Waschmaschine.y = waschmaschineY;

     
    }
  
    return keyvaluepositions;
  }
  
//const updatedKeyvaluepositions = setYValuesFromEntlader(pathsFromEntpackerSenke1, keyvaluepositions);
//console.log(updatedKeyvaluepositions);
  


// neuer Versuch
// Funktion, die die Node Positions berechnet
function calcpositionshor_r (path, width, height){
  const firstMachine = path[0][0];
  for (let i = 0; i < path[0].length; i++) {
    const machineName = path[0][i];
    const currentMachine = keyvaluepositions[machineName];
    const xOffset = i * width;
    currentMachine.y = keyvaluepositions[firstMachine].y;
    currentMachine.x = keyvaluepositions[firstMachine].x + xOffset;
  }
  return keyvaluepositions;
}
function calcpositionshor_l (path, width, height){
  const firstMachine = path[0][0];
  for (let i = 0; i < path[0].length; i++) {
    const machineName = path[0][i];
    const currentMachine = keyvaluepositions[machineName];
    const xOffset = i * width;
    currentMachine.y = keyvaluepositions[firstMachine].y;
    currentMachine.x = keyvaluepositions[firstMachine].x - xOffset;
  }
  return keyvaluepositions;
}

function calcpositionssenkr_u(path, width, height) {
    const firstMachine = path[0][0];
    for (let i = 0; i < path[0].length; i++) {
      const machineName = path[0][i];
      const currentMachine = keyvaluepositions[machineName];
      const yOffset = i * height;
      // Setze den x-Wert der aktuellen Maschine auf den x-Wert der ersten Maschine (fixe Maschine)
      currentMachine.x = keyvaluepositions[firstMachine].x;
      // Setze den y-Wert der aktuellen Maschine entsprechend dem yOffset
      currentMachine.y = keyvaluepositions[firstMachine].y + yOffset;
    }
    return keyvaluepositions;
  }


//function calcpositionssenkr_o (path, width, height){}

function calcpositionshor_l (path, width, height){
  for (machineName of path[0]){
    keyvaluepositions[machineName].y = keyvaluepositions[machineName].x - width;
  }
}


calcpositionssenkr_u(path2_Auspacker);
calcpositionssenkr_u(path2_Entlader);
//console.log(calcpositionshor_r(path1,nodeWith,nodeHeight));
console.log(path1_hor_r);











// Funktion, die die Node Positions berechnet
function calculateNodePositions(startX, startY, endX, endY, nodeCount, nodeWith, nodeHeight) {
  var gap = (endY - startY) / (nodeCount + 1); // Berechnung des vertikalen Abstands
  var nodePositions = [];
  for (var i = 1; i <= nodeCount; i++) {
    var x = startX; // x-Koordinate ist konstant, da senkrecht unterhalb des Startpunkts
    var y = startY + (gap * i); // Berechnung der y-Koordinate
    nodePositions.push({ x: x, y: y }); // Hinzufügen der Knotenposition zur Liste
  }
  return nodePositions;
}
//console.log(calculateNodePositions(xEntladerPosition,yEntladerPosition,1400,3000,8));














// Funktion, die die nächsten Maschinen ausgehend von Start-Maschine berechnet
function iterateMatrix(matrix, inputString) {
    const columnNames = []; // Liste für Spaltennamen, in denen eine 1 steht
    // Finde die Zeile, die den Input-String enthält
    const row = matrix.find(row => row.includes(inputString));
  
    if (!row) {
      console.log("Der Input-String wurde nicht gefunden.");
      return columnNames;
    }
    const columnIndex = row.indexOf(inputString);
    const startRow = matrix.indexOf(row);
    for (let currentRow = startRow; currentRow < matrix.length; currentRow++) {
      // Überprüfe, ob die Spalte in der aktuellen Zeile eine 1 enthält
      if (matrix[currentRow][columnIndex] === '1') { // Beachte: Vergleich mit '1' als String
        // Finde den Spaltennamen für diese Spalte
        const columnName = matrix.map(row => row[4]).slice(2);
        columnNames.push(columnName);
        // Springe zur nächsten Spalte mit 1 in derselben Zeile
        let nextColumnIndex = columnIndex + 1;
        while (nextColumnIndex < matrix[currentRow].length && matrix[currentRow][nextColumnIndex] !== '1') {
          nextColumnIndex++;
        }
        // Wenn keine weitere Spalte mit 1 in derselben Zeile gefunden wurde, springe zur nächsten Zeile
        if (nextColumnIndex === matrix[currentRow].length) {
          nextColumnIndex = row.indexOf('1', nextColumnIndex); // Finde den nächsten Spaltenindex mit 1 in der Ausgangszeile
          if (nextColumnIndex === -1) {
            break; // Keine weiteren Spalten mit 1 gefunden, beende die Schleife
          }
          currentRow = startRow - 1; // Setze die aktuelle Zeile auf die Ausgangszeile minus 1, da die Schleife die Zeile erhöht
        }
        columnIndex = nextColumnIndex; // Aktualisiere den Spaltenindex
      }
    }
    return columnNames;
  }
  
  
  //console.log(iterateMatrix(matrix,"Entlader"));
 
